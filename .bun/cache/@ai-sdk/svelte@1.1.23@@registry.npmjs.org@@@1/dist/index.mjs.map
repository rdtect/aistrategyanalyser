{"version":3,"sources":["../src/use-chat.ts","../src/use-completion.ts","../src/use-assistant.ts"],"sourcesContent":["import type {\n  ChatRequest,\n  ChatRequestOptions,\n  CreateMessage,\n  JSONValue,\n  Message,\n  UseChatOptions as SharedUseChatOptions,\n  UIMessage,\n} from '@ai-sdk/ui-utils';\nimport {\n  callChatApi,\n  extractMaxToolInvocationStep,\n  fillMessageParts,\n  generateId as generateIdFunc,\n  getMessageParts,\n  isAssistantMessageWithCompletedToolCalls,\n  prepareAttachmentsForRequest,\n  shouldResubmitMessages,\n  updateToolCallResult,\n} from '@ai-sdk/ui-utils';\nimport { Readable, Writable, derived, get, writable } from 'svelte/store';\nexport type { CreateMessage, Message };\n\nexport type UseChatOptions = SharedUseChatOptions & {\n  /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n */\n  maxSteps?: number;\n};\n\nexport type UseChatHelpers = {\n  /** Current messages in the chat */\n  messages: Readable<UIMessage[]>;\n  /** The error object of the API request */\n  error: Readable<undefined | Error>;\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   * @param chatRequestOptions Additional options to pass to the API call\n   */\n  append: (\n    message: Message | CreateMessage,\n    chatRequestOptions?: ChatRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: (\n    chatRequestOptions?: ChatRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n  /**\n   * Update the `messages` state locally. This is useful when you want to\n   * edit the messages on the client, and then trigger the `reload` method\n   * manually to regenerate the AI response.\n   */\n  setMessages: (\n    messages: Message[] | ((messages: Message[]) => Message[]),\n  ) => void;\n\n  /** The current value of the input */\n  input: Writable<string>;\n  /** Form submission handler to automatically reset input and append a user message  */\n  handleSubmit: (\n    event?: { preventDefault?: () => void },\n    chatRequestOptions?: ChatRequestOptions,\n  ) => void;\n  metadata?: Object;\n\n  /**\n   * Whether the API request is in progress\n   *\n   * @deprecated use `status` instead\n   */\n  isLoading: Readable<boolean | undefined>;\n\n  /**\n   * Hook status:\n   *\n   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.\n   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.\n   * - `ready`: The full response has been received and processed; a new user message can be submitted.\n   * - `error`: An error occurred during the API request, preventing successful completion.\n   */\n  status: Readable<'submitted' | 'streaming' | 'ready' | 'error'>;\n\n  /** Additional data added on the server via StreamData */\n  data: Readable<JSONValue[] | undefined>;\n  /** Set the data of the chat. You can use this to transform or clear the chat data. */\n  setData: (\n    data:\n      | JSONValue[]\n      | undefined\n      | ((data: JSONValue[] | undefined) => JSONValue[] | undefined),\n  ) => void;\n\n  /** The id of the chat */\n  id: string;\n};\n\nconst store = writable<Record<string, UIMessage[] | undefined>>({});\n\nexport function useChat({\n  api = '/api/chat',\n  id,\n  initialMessages = [],\n  initialInput = '',\n  sendExtraMessageFields,\n  streamProtocol = 'data',\n  onResponse,\n  onFinish,\n  onError,\n  onToolCall,\n  credentials,\n  headers,\n  body,\n  generateId = generateIdFunc,\n  fetch,\n  keepLastMessageOnError = true,\n  maxSteps = 1,\n}: UseChatOptions = {}): UseChatHelpers & {\n  addToolResult: ({\n    toolCallId,\n    result,\n  }: {\n    toolCallId: string;\n    result: any;\n  }) => void;\n} {\n  // Generate a unique id for the chat if not provided.\n  const chatId = id ?? generateId();\n\n  const key = `${api}|${chatId}`;\n  const messages = derived(\n    [store],\n    ([$store]) => $store[key] ?? fillMessageParts(initialMessages),\n  );\n\n  const streamData = writable<JSONValue[] | undefined>(undefined);\n\n  const status = writable<'submitted' | 'streaming' | 'ready' | 'error'>(\n    'ready',\n  );\n\n  const mutate = (data: UIMessage[]) => {\n    store.update(value => {\n      value[key] = data;\n      return value;\n    });\n  };\n\n  // Abort controller to cancel the current API call.\n  let abortController: AbortController | null = null;\n\n  const extraMetadata = {\n    credentials,\n    headers,\n    body,\n  };\n\n  const error = writable<undefined | Error>(undefined);\n\n  // Actual mutation hook to send messages to the API endpoint and update the\n  // chat state.\n  async function triggerRequest(chatRequest: ChatRequest) {\n    status.set('submitted');\n    error.set(undefined);\n\n    const messagesSnapshot = get(messages);\n    const messageCount = messagesSnapshot.length;\n    const maxStep = extractMaxToolInvocationStep(\n      chatRequest.messages[chatRequest.messages.length - 1]?.toolInvocations,\n    );\n\n    try {\n      abortController = new AbortController();\n\n      // Do an optimistic update to the chat state to show the updated messages\n      // immediately.\n      const chatMessages = fillMessageParts(chatRequest.messages);\n\n      mutate(chatMessages);\n\n      const existingData = get(streamData);\n      const previousMessages = get(messages);\n\n      const constructedMessagesPayload = sendExtraMessageFields\n        ? chatMessages\n        : chatMessages.map(\n            ({\n              role,\n              content,\n              experimental_attachments,\n              data,\n              annotations,\n              toolInvocations,\n              parts,\n            }) => ({\n              role,\n              content,\n              ...(experimental_attachments !== undefined && {\n                experimental_attachments,\n              }),\n              ...(data !== undefined && { data }),\n              ...(annotations !== undefined && { annotations }),\n              ...(toolInvocations !== undefined && { toolInvocations }),\n              ...(parts !== undefined && { parts }),\n            }),\n          );\n\n      await callChatApi({\n        api,\n        body: {\n          id: chatId,\n          messages: constructedMessagesPayload,\n          data: chatRequest.data,\n          ...extraMetadata.body,\n          ...chatRequest.body,\n        },\n        streamProtocol,\n        credentials: extraMetadata.credentials,\n        headers: {\n          ...extraMetadata.headers,\n          ...chatRequest.headers,\n        },\n        abortController: () => abortController,\n        restoreMessagesOnFailure() {\n          if (!keepLastMessageOnError) {\n            mutate(previousMessages);\n          }\n        },\n        onResponse,\n        onUpdate({ message, data, replaceLastMessage }) {\n          status.set('streaming');\n\n          mutate([\n            ...(replaceLastMessage\n              ? chatMessages.slice(0, chatMessages.length - 1)\n              : chatMessages),\n            message,\n          ]);\n          if (data?.length) {\n            streamData.set([...(existingData ?? []), ...data]);\n          }\n        },\n        onFinish,\n        generateId,\n        onToolCall,\n        fetch,\n        lastMessage: chatMessages[chatMessages.length - 1],\n      });\n\n      status.set('ready');\n    } catch (err) {\n      // Ignore abort errors as they are expected.\n      if ((err as any).name === 'AbortError') {\n        abortController = null;\n        status.set('ready');\n        return null;\n      }\n\n      if (onError && err instanceof Error) {\n        onError(err);\n      }\n\n      error.set(err as Error);\n      status.set('error');\n    } finally {\n      abortController = null;\n    }\n\n    // auto-submit when all tool calls in the last assistant message have results:\n    const newMessagesSnapshot = get(messages);\n    if (\n      shouldResubmitMessages({\n        originalMaxToolInvocationStep: maxStep,\n        originalMessageCount: messageCount,\n        maxSteps,\n        messages: newMessagesSnapshot,\n      })\n    ) {\n      await triggerRequest({ messages: newMessagesSnapshot });\n    }\n  }\n\n  const append: UseChatHelpers['append'] = async (\n    message: Message | CreateMessage,\n    { data, headers, body, experimental_attachments }: ChatRequestOptions = {},\n  ) => {\n    const attachmentsForRequest = await prepareAttachmentsForRequest(\n      experimental_attachments,\n    );\n\n    return triggerRequest({\n      messages: get(messages).concat({\n        ...message,\n        id: message.id ?? generateId(),\n        createdAt: message.createdAt ?? new Date(),\n        experimental_attachments:\n          attachmentsForRequest.length > 0 ? attachmentsForRequest : undefined,\n        parts: getMessageParts(message),\n      }),\n      headers,\n      body,\n      data,\n    });\n  };\n\n  const reload: UseChatHelpers['reload'] = async ({\n    data,\n    headers,\n    body,\n  }: ChatRequestOptions = {}) => {\n    const messagesSnapshot = get(messages);\n    if (messagesSnapshot.length === 0) {\n      return null;\n    }\n\n    // Remove last assistant message and retry last user message.\n    const lastMessage = messagesSnapshot.at(-1);\n    return triggerRequest({\n      messages:\n        lastMessage?.role === 'assistant'\n          ? messagesSnapshot.slice(0, -1)\n          : messagesSnapshot,\n      headers,\n      body,\n      data,\n    });\n  };\n\n  const stop = () => {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  };\n\n  const setMessages = (\n    messagesArg: Message[] | ((messages: Message[]) => Message[]),\n  ) => {\n    if (typeof messagesArg === 'function') {\n      messagesArg = messagesArg(get(messages));\n    }\n\n    mutate(fillMessageParts(messagesArg));\n  };\n\n  const setData = (\n    dataArg:\n      | JSONValue[]\n      | undefined\n      | ((data: JSONValue[] | undefined) => JSONValue[] | undefined),\n  ) => {\n    if (typeof dataArg === 'function') {\n      dataArg = dataArg(get(streamData));\n    }\n\n    streamData.set(dataArg);\n  };\n\n  const input = writable(initialInput);\n\n  const handleSubmit = async (\n    event?: { preventDefault?: () => void },\n    options: ChatRequestOptions = {},\n  ) => {\n    event?.preventDefault?.();\n    const inputValue = get(input);\n\n    if (!inputValue && !options.allowEmptySubmit) return;\n\n    const attachmentsForRequest = await prepareAttachmentsForRequest(\n      options.experimental_attachments,\n    );\n\n    triggerRequest({\n      messages: get(messages).concat({\n        id: generateId(),\n        content: inputValue,\n        role: 'user',\n        createdAt: new Date(),\n        experimental_attachments:\n          attachmentsForRequest.length > 0 ? attachmentsForRequest : undefined,\n        parts: [{ type: 'text', text: inputValue }],\n      }),\n      body: options.body,\n      headers: options.headers,\n      data: options.data,\n    });\n\n    input.set('');\n  };\n\n  const addToolResult = ({\n    toolCallId,\n    result,\n  }: {\n    toolCallId: string;\n    result: any;\n  }) => {\n    const messagesSnapshot = get(messages) ?? [];\n\n    updateToolCallResult({\n      messages: messagesSnapshot,\n      toolCallId,\n      toolResult: result,\n    });\n\n    mutate(messagesSnapshot);\n\n    // auto-submit when all tool calls in the last assistant message have results:\n    const lastMessage = messagesSnapshot[messagesSnapshot.length - 1];\n\n    if (isAssistantMessageWithCompletedToolCalls(lastMessage)) {\n      triggerRequest({ messages: messagesSnapshot });\n    }\n  };\n\n  return {\n    id: chatId,\n    messages,\n    error,\n    append,\n    reload,\n    stop,\n    setMessages,\n    input,\n    handleSubmit,\n    isLoading: derived(\n      status,\n      $status => $status === 'submitted' || $status === 'streaming',\n    ),\n    status,\n    data: streamData,\n    setData,\n    addToolResult,\n  };\n}\n","import type {\n  JSONValue,\n  RequestOptions,\n  UseCompletionOptions,\n} from '@ai-sdk/ui-utils';\nimport { callCompletionApi } from '@ai-sdk/ui-utils';\nimport { Readable, Writable, derived, get, writable } from 'svelte/store';\n\nexport type { UseCompletionOptions };\n\nexport type UseCompletionHelpers = {\n  /** The current completion result */\n  completion: Readable<string>;\n  /** The error object of the API request */\n  error: Readable<undefined | Error>;\n  /**\n   * Send a new prompt to the API endpoint and update the completion state.\n   */\n  complete: (\n    prompt: string,\n    options?: RequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Abort the current API request but keep the generated tokens.\n   */\n  stop: () => void;\n  /**\n   * Update the `completion` state locally.\n   */\n  setCompletion: (completion: string) => void;\n  /** The current value of the input */\n  input: Writable<string>;\n  /**\n   * Form submission handler to automatically reset input and append a user message\n   * @example\n   * ```jsx\n   * <form onSubmit={handleSubmit}>\n   *  <input onChange={handleInputChange} value={input} />\n   * </form>\n   * ```\n   */\n  handleSubmit: (event?: { preventDefault?: () => void }) => void;\n  /** Whether the API request is in progress */\n  isLoading: Readable<boolean | undefined>;\n\n  /** Additional data added on the server via StreamData */\n  data: Readable<JSONValue[] | undefined>;\n};\n\nlet uniqueId = 0;\n\nconst store = writable<Record<string, string>>({});\n\nexport function useCompletion({\n  api = '/api/completion',\n  id,\n  initialCompletion = '',\n  initialInput = '',\n  credentials,\n  headers,\n  body,\n  streamProtocol = 'data',\n  onResponse,\n  onFinish,\n  onError,\n  fetch,\n}: UseCompletionOptions = {}): UseCompletionHelpers {\n  // Generate an unique id for the completion if not provided.\n  const completionId = id || `completion-${uniqueId++}`;\n\n  const key = `${api}|${completionId}`;\n  const data = derived([store], ([$store]) => $store[key] ?? initialCompletion);\n\n  const streamData = writable<JSONValue[] | undefined>(undefined);\n\n  const loading = writable<boolean>(false);\n\n  const mutate = (data: string) => {\n    store.update(value => {\n      value[key] = data;\n      return value;\n    });\n  };\n\n  // Because of the `fallbackData` option, the `data` will never be `undefined`.\n  const completion = data;\n\n  const error = writable<undefined | Error>(undefined);\n\n  let abortController: AbortController | null = null;\n\n  const complete: UseCompletionHelpers['complete'] = async (\n    prompt: string,\n    options?: RequestOptions,\n  ) => {\n    const existingData = get(streamData);\n    return callCompletionApi({\n      api,\n      prompt,\n      credentials,\n      headers: {\n        ...headers,\n        ...options?.headers,\n      },\n      body: {\n        ...body,\n        ...options?.body,\n      },\n      streamProtocol,\n      setCompletion: mutate,\n      setLoading: loadingState => loading.set(loadingState),\n      setError: err => error.set(err),\n      setAbortController: controller => {\n        abortController = controller;\n      },\n      onResponse,\n      onFinish,\n      onError,\n      onData(data) {\n        streamData.set([...(existingData || []), ...(data || [])]);\n      },\n      fetch,\n    });\n  };\n\n  const stop = () => {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  };\n\n  const setCompletion = (completion: string) => {\n    mutate(completion);\n  };\n\n  const input = writable(initialInput);\n\n  const handleSubmit = (event?: { preventDefault?: () => void }) => {\n    event?.preventDefault?.();\n\n    const inputValue = get(input);\n    return inputValue ? complete(inputValue) : undefined;\n  };\n\n  return {\n    completion,\n    complete,\n    error,\n    stop,\n    setCompletion,\n    input,\n    handleSubmit,\n    isLoading: loading,\n    data: streamData,\n  };\n}\n","import { isAbortError } from '@ai-sdk/provider-utils';\nimport type {\n  AssistantStatus,\n  CreateMessage,\n  Message,\n  UseAssistantOptions,\n} from '@ai-sdk/ui-utils';\nimport { generateId, processAssistantStream } from '@ai-sdk/ui-utils';\nimport { Readable, Writable, get, writable } from 'svelte/store';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nlet uniqueId = 0;\n\nconst store: Record<string, any> = {};\n\nexport type UseAssistantHelpers = {\n  /**\n   * The current array of chat messages.\n   */\n  messages: Readable<Message[]>;\n\n  /**\n   * Update the message store with a new array of messages.\n   */\n  setMessages: (messages: Message[]) => void;\n\n  /**\n   * The current thread ID.\n   */\n  threadId: Readable<string | undefined>;\n\n  /**\n   * The current value of the input field.\n   */\n  input: Writable<string>;\n\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   * @param requestOptions Additional options to pass to the API call\n   */\n  append: (\n    message: Message | CreateMessage,\n    requestOptions?: { data?: Record<string, string> },\n  ) => Promise<void>;\n\n  /**\nAbort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n\n  /**\n   * Form submission handler that automatically resets the input field and appends a user message.\n   */\n  submitMessage: (\n    event?: { preventDefault?: () => void },\n    requestOptions?: { data?: Record<string, string> },\n  ) => Promise<void>;\n\n  /**\n   * The current status of the assistant. This can be used to show a loading indicator.\n   */\n  status: Readable<AssistantStatus>;\n\n  /**\n   * The error thrown during the assistant message processing, if any.\n   */\n  error: Readable<undefined | Error>;\n};\n\nexport function useAssistant({\n  api,\n  threadId: threadIdParam,\n  credentials,\n  headers,\n  body,\n  onError,\n  fetch,\n}: UseAssistantOptions): UseAssistantHelpers {\n  // Generate a unique thread ID\n  const threadIdStore = writable<string | undefined>(threadIdParam);\n\n  // Initialize message, input, status, and error stores\n  const key = `${api}|${threadIdParam ?? `completion-${uniqueId++}`}`;\n  const messages = writable<Message[]>(store[key] || []);\n  const input = writable('');\n  const status = writable<AssistantStatus>('awaiting_message');\n  const error = writable<undefined | Error>(undefined);\n\n  // To manage aborting the current fetch request\n  let abortController: AbortController | null = null;\n\n  // Update the message store\n  const mutateMessages = (newMessages: Message[]) => {\n    store[key] = newMessages;\n    messages.set(newMessages);\n  };\n\n  // Function to handle API calls and state management\n  async function append(\n    message: Message | CreateMessage,\n    requestOptions?: { data?: Record<string, string> },\n  ) {\n    status.set('in_progress');\n    abortController = new AbortController(); // Initialize a new AbortController\n\n    // Add the new message to the existing array\n    mutateMessages([\n      ...get(messages),\n      { ...message, id: message.id ?? generateId() },\n    ]);\n\n    input.set('');\n\n    try {\n      const actualFetch = fetch ?? getOriginalFetch();\n      const response = await actualFetch(api, {\n        method: 'POST',\n        credentials,\n        signal: abortController.signal,\n        headers: { 'Content-Type': 'application/json', ...headers },\n        body: JSON.stringify({\n          ...body,\n          // always use user-provided threadId when available:\n          threadId: threadIdParam ?? get(threadIdStore) ?? null,\n          message: message.content,\n\n          // optional request data:\n          data: requestOptions?.data,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          (await response.text()) ?? 'Failed to fetch the assistant response.',\n        );\n      }\n\n      if (response.body == null) {\n        throw new Error('The response body is empty.');\n      }\n\n      await processAssistantStream({\n        stream: response.body,\n        onAssistantMessagePart(value) {\n          mutateMessages([\n            ...get(messages),\n            {\n              id: value.id,\n              role: value.role,\n              content: value.content[0].text.value,\n              parts: [],\n            },\n          ]);\n        },\n        onTextPart(value) {\n          // text delta - add to last message:\n          mutateMessages(\n            get(messages).map((msg, index, array) => {\n              if (index === array.length - 1) {\n                return { ...msg, content: msg.content + value };\n              }\n              return msg;\n            }),\n          );\n        },\n        onAssistantControlDataPart(value) {\n          threadIdStore.set(value.threadId);\n\n          mutateMessages(\n            get(messages).map((msg, index, array) => {\n              if (index === array.length - 1) {\n                return { ...msg, id: value.messageId };\n              }\n              return msg;\n            }),\n          );\n        },\n        onDataMessagePart(value) {\n          mutateMessages([\n            ...get(messages),\n            {\n              id: value.id ?? generateId(),\n              role: 'data',\n              content: '',\n              data: value.data,\n              parts: [],\n            },\n          ]);\n        },\n        onErrorPart(value) {\n          error.set(new Error(value));\n        },\n      });\n    } catch (err) {\n      // Ignore abort errors as they are expected when the user cancels the request:\n      if (isAbortError(error) && abortController?.signal?.aborted) {\n        abortController = null;\n        return;\n      }\n\n      if (onError && err instanceof Error) {\n        onError(err);\n      }\n\n      error.set(err as Error);\n    } finally {\n      abortController = null;\n      status.set('awaiting_message');\n    }\n  }\n\n  function setMessages(messages: Message[]) {\n    mutateMessages(messages);\n  }\n\n  function stop() {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  }\n\n  // Function to handle form submission\n  async function submitMessage(\n    event?: { preventDefault?: () => void },\n    requestOptions?: { data?: Record<string, string> },\n  ) {\n    event?.preventDefault?.();\n    const inputValue = get(input);\n    if (!inputValue) return;\n\n    await append(\n      { role: 'user', content: inputValue, parts: [] },\n      requestOptions,\n    );\n  }\n\n  return {\n    messages,\n    error,\n    threadId: threadIdStore,\n    input,\n    append,\n    submitMessage,\n    status,\n    setMessages,\n    stop,\n  };\n}\n"],"mappings":"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","names":["generateId","fetch","headers","body","derived","get","writable","store","fetch","data","completion","get","writable","uniqueId","store","fetch","_a","messages"]}